q!
reset
self.board[mvs[0]].is_a?(NullPiece)
mvs
q!
mvs
q!
pos
y
x
c
s
pos
s
pos
s
@board[1][1].pos
pos
s
@board[5][1].pos
@board[5][1].pos = pos
@board[5][1].pos
@board[5][1]
pos
value
q
s
mvs
q!
c
memo
n
dy
dx
pos
c
q!
q
reset
dy
dx
pos
board.class
board.class?
board
q!
@board
c
@board
board
q!
var instance
q!
self.send child
self.child
self.set_inst
child
self.methods
self
q!
self.set_inst
child
c
self.set_inst
self
child
q!
child
self
end
  end
    # self.extend NewModule    
    end
      include Caught
      include NewModule
    class << self 
    @class = true
  def initialize
class NewClass
q!
child
self
reset
end
  end
    # self.extend NewModule    
    end
      include Caught
      include NewModule
    class << self 
    @class = true
  def initialize
class NewClass
end
  end
    # end
    #   child.singleton_class.remove_method :set_inst
    #   child.send :set_inst
    # def extended(child)
    end
    def extended(child)
    end
      child.extend self
      end
        self.instance_variable_set(:@set_inst, "test")
      child.define_method :set_inst do
    def included(child)
  class << self
module NewModule
quit
self
var all
q!
child.set_inst
child
q!
c = NewClass.new
child.butts
child.define_method :butts do p "butts" end
child.define_method :butts { p "butts" }
child.define_method :butts do
child.private_methods - Object.private_methods
child.private_methods
child.methods - Object.methods
child.methods - [].methods
child.methods = [].methods
child
c = NewClass.new
quit
[].send(:test)
child.send(:test)
child.test
child.methods - Object.methods
child.methods
child
q!
child
NewClass.instance_variables
q!
c
child
c
child
c
q!
self[([1,1])]
self[[1,1]]
self[1,1]
self[start_pos]
start_pos
q!
z
y
x
